using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using CombineFiles.Core.Configuration;
using CombineFiles.Core.Helpers;
using CombineFiles.Core.Infrastructure;

namespace CombineFiles.Core.Services;

/// <summary>
/// Servizio per logica di filtraggio avanzato dei file (dimensione, data, contenuto).
/// </summary>
public class FileFilterService
{
    private readonly Logger _logger;
    private readonly string _basePath;

    public FileFilterService(Logger logger)
    {
        _logger = logger;
        _basePath = Directory.GetCurrentDirectory();
    }

    /// <summary>
    /// Filtra i file in base a dimensione, data e contenuto auto-generated.
    /// Unifica la logica di FilterBySize e FilterByDateAndSize.
    /// </summary>
    public List<string> FilterFiles(List<string> files, CombineFilesOptions options)
    {
        var (minBytes, maxBytes) = ParseSizeLimits(options);

        var filtered = files.Where(file =>
        {
            file = FileHelper.NormalizeLongPath(file);
            FileInfo fi;
            try
            {
                fi = new FileInfo(file);
            }
            catch (Exception ex)
            {
                _logger.WriteLog($"Errore nel leggere informazioni di {GetRelativePath(file)}: {ex.Message}", LogLevel.WARNING);
                return false;
            }

            // 1) Filtra per dimensione minima
            if (minBytes > 0 && fi.Length < minBytes)
            {
                _logger.WriteLog($"Escludo per dimensione < MinSize: {GetRelativePath(file)} ({fi.Length} byte)", LogLevel.DEBUG);
                return false;
            }

            // 2) Filtra per dimensione massima
            if (maxBytes > 0 && fi.Length > maxBytes)
            {
                _logger.WriteLog($"Escludo per dimensione > MaxSize: {GetRelativePath(file)} ({fi.Length} byte)", LogLevel.DEBUG);
                return false;
            }

            // 3) Filtra per data minima
            if (options.MinDate.HasValue && fi.CreationTime < options.MinDate.Value)
            {
                _logger.WriteLog($"Escludo per data < MinDate: {GetRelativePath(file)}", LogLevel.DEBUG);
                return false;
            }

            // 4) Filtra per data massima
            if (options.MaxDate.HasValue && fi.CreationTime > options.MaxDate.Value)
            {
                _logger.WriteLog($"Escludo per data > MaxDate: {GetRelativePath(file)}", LogLevel.DEBUG);
                return false;
            }

            return true;
        }).ToList();

        int removedCount = files.Count - filtered.Count;
        if (removedCount > 0)
        {
            _logger.WriteLog($"Filtraggio dimensione/data: rimossi {removedCount} file, rimangono {filtered.Count}", LogLevel.INFO);
        }

        return filtered;
    }

    /// <summary>
    /// Filtra i file escludendo quelli con contenuto auto-generated.
    /// </summary>
    public List<string> FilterAutoGenerated(List<string> files)
    {
        var filtered = files.Where(f => !FileContainsAutoGenerated(f)).ToList();
        int removedCount = files.Count - filtered.Count;
        if (removedCount > 0)
        {
            _logger.WriteLog($"Totale file dopo esclusione 'auto-generated': {filtered.Count} (rimossi {removedCount})", LogLevel.INFO);
        }
        return filtered;
    }

    /// <summary>
    /// Controlla se il file contiene nel contenuto la stringa "&lt;auto-generated" o "&lt;autogenerated".
    /// </summary>
    public bool FileContainsAutoGenerated(string filePath)
    {
        filePath = FileHelper.NormalizeLongPath(filePath);
        try
        {
            string content = File.ReadAllText(filePath);
            if (content.IndexOf("<auto-generated", StringComparison.OrdinalIgnoreCase) >= 0 ||
                content.IndexOf("<autogenerated", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                _logger.WriteLog($"File escluso per contenuto auto-generated: {GetRelativePath(filePath)}", LogLevel.DEBUG);
                return true;
            }
        }
        catch (Exception ex)
        {
            _logger.WriteLog($"Errore nella lettura di {GetRelativePath(filePath)}: {ex.Message}", LogLevel.WARNING);
        }
        return false;
    }

    /// <summary>
    /// Estrae e valida i limiti di dimensione dalle opzioni.
    /// </summary>
    private (long minBytes, long maxBytes) ParseSizeLimits(CombineFilesOptions options)
    {
        long maxBytes = 0;
        long minBytes = 0;

        if (!string.IsNullOrWhiteSpace(options.MaxSize))
        {
            try
            {
                maxBytes = FileHelper.ConvertSizeToBytes(options.MaxSize);
            }
            catch (Exception ex)
            {
                _logger.WriteLog($"Formato MaxSize non valido ('{options.MaxSize}'): {ex.Message}", LogLevel.WARNING);
            }
        }

        if (!string.IsNullOrWhiteSpace(options.MinSize))
        {
            try
            {
                minBytes = FileHelper.ConvertSizeToBytes(options.MinSize);
            }
            catch (Exception ex)
            {
                _logger.WriteLog($"Formato MinSize non valido ('{options.MinSize}'): {ex.Message}", LogLevel.WARNING);
            }
        }

        return (minBytes, maxBytes);
    }

    /// <summary>
    /// Converte un percorso assoluto in relativo rispetto a _basePath.
    /// </summary>
    private string GetRelativePath(string fullPath)
    {
        try
        {
            return FileHelper.GetRelativePath(_basePath, fullPath);
        }
        catch
        {
            return fullPath;
        }
    }
}

