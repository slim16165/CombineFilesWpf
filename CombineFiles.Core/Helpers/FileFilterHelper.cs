using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using CombineFiles.Core.Configuration;
using CombineFiles.Core.Infrastructure;

namespace CombineFiles.Core.Helpers;

public static class FileFilterHelper
{
    /// <summary>
    /// Filtra la lista di file in base a MinDate, MaxDate, MinSize, MaxSize.
    /// </summary>
    public static List<string> FilterByDateAndSize(List<string> files, CombineFilesOptions options, Logger logger)
    {
        long minSize = string.IsNullOrWhiteSpace(options.MinSize)
            ? 0
            : FileHelper.ConvertSizeToBytes(options.MinSize);

        long maxSize = string.IsNullOrWhiteSpace(options.MaxSize)
            ? long.MaxValue
            : FileHelper.ConvertSizeToBytes(options.MaxSize);

        DateTime? minDate = options.MinDate;
        DateTime? maxDate = options.MaxDate;

        var filtered = new List<string>();

        foreach (var f in files)
        {
            try
            {
                var info = new FileInfo(f);

                bool sizeOk = info.Length >= minSize && info.Length <= maxSize;
                bool dateOk = (!minDate.HasValue || info.LastWriteTime >= minDate.Value)
                              && (!maxDate.HasValue || info.LastWriteTime <= maxDate.Value);

                if (sizeOk && dateOk)
                    filtered.Add(f);
            }
            catch (Exception ex)
            {
                logger.WriteLog($"Errore nell'accesso a {f}: {ex.Message}", "WARNING");
            }
        }

        logger.WriteLog($"File rimasti dopo filtro date/dimensioni: {filtered.Count}", "INFO");
        return filtered;
    }

    /// <summary>
    /// Ritorna true se il file contiene la stringa "auto-generated", false altrimenti.
    /// </summary>
    public static bool FileContainsAutoGenerated(string filePath, Logger logger)
    {
        try
        {
            var lines = File.ReadAllLines(filePath);
            foreach (var line in lines)
            {
                if (line.Contains("<auto-generated>"))
                {
                    logger.WriteLog($"File escluso per contenuto auto-generated: {filePath}", "INFO");
                    return true;
                }
            }
        }
        catch (Exception ex)
        {
            logger.WriteLog($"Impossibile controllare 'auto-generated' su {filePath}: {ex.Message}", "WARNING");
        }
        return false;
    }

    /// <summary>
    /// Verifica se il file deve essere incluso in base alle opzioni di filtro.
    /// </summary>
    /// <param name="filePath">Il percorso completo del file.</param>
    /// <param name="excludeHidden">Se escludere i file nascosti.</param>
    /// <param name="excludePaths">Percorsi (separati da virgola o punto e virgola) da escludere.</param>
    /// <param name="excludeExtensions">Estensioni (separati da virgola o punto e virgola) da escludere.</param>
    /// <param name="includeExtensions">Se specificato, includi solo questi file (separati da virgola o punto e virgola).</param>
    /// <returns>true se il file deve essere incluso, altrimenti false.</returns>
    public static bool ShouldIncludeFile(string filePath, bool excludeHidden, string excludePaths, string excludeExtensions, string includeExtensions)
    {
        // Escludi file nascosti
        if (excludeHidden && (new FileInfo(filePath).Attributes.HasFlag(FileAttributes.Hidden)))
        {
            return false;
        }

        // Escludi percorsi specifici
        if (!string.IsNullOrWhiteSpace(excludePaths))
        {
            var paths = excludePaths.Split([',', ';'], StringSplitOptions.RemoveEmptyEntries);
            foreach (var path in paths)
            {
                if (filePath.IndexOf(path, StringComparison.OrdinalIgnoreCase) >= 0)
                    return false;
            }
        }

        string extension = Path.GetExtension(filePath).ToLower();

        // Escludi estensioni specifiche
        if (!string.IsNullOrWhiteSpace(excludeExtensions))
        {
            var extList = excludeExtensions.Split([',', ';'], StringSplitOptions.RemoveEmptyEntries);
            if (Array.Exists(extList, e => e.Equals(extension, StringComparison.OrdinalIgnoreCase)))
                return false;
        }

        // Includi solo estensioni specifiche se definite
        if (!string.IsNullOrWhiteSpace(includeExtensions))
        {
            var includeList = includeExtensions.Split([',', ';'], StringSplitOptions.RemoveEmptyEntries);
            if (!Array.Exists(includeList, e => e.Equals(extension, StringComparison.OrdinalIgnoreCase)))
                return false;
        }

        return true;
    }

    /// <summary>
    /// Verifica se il file deve essere incluso in base alle opzioni di filtro.
    /// </summary>
    /// <param name="filePath">Il percorso completo del file.</param>
    /// <returns>true se il file deve essere incluso, altrimenti false.</returns>
    public static bool ShouldIncludeFile(string filePath, FileSearchConfig config)
    {
        var fileInfo = new FileInfo(filePath);
        if (config.ExcludeHidden && fileInfo.Attributes.HasFlag(FileAttributes.Hidden)) return false;

        var excludePaths = config.ExcludePaths?.Split([',', ';'], StringSplitOptions.RemoveEmptyEntries)
            .Select(p => p.Trim()).ToHashSet(StringComparer.OrdinalIgnoreCase) ?? [];
        if (excludePaths.Any(p => filePath.IndexOf(p, StringComparison.OrdinalIgnoreCase) >= 0)) return false;

        string extension = Path.GetExtension(filePath).ToLower();
        var excludeExts = config.ExcludeExtensions?.Split([',', ';'], StringSplitOptions.RemoveEmptyEntries)
            .Select(e => e.Trim().ToLower()).ToHashSet() ?? [];
        if (excludeExts.Contains(extension)) return false;

        var includeExts = config.IncludeExtensions?.Split([',', ';'], StringSplitOptions.RemoveEmptyEntries)
            .Select(e => e.Trim().ToLower()).ToHashSet() ?? [];
        if (includeExts.Any() && !includeExts.Contains(extension)) return false;

        return true;
    }
}
