# FileSelection.psm1

function Convert-SizeToBytes {
    param (
        [string]$Size
    )
    switch -Regex ($Size) {
        '^(\d+)\s*KB$' { return [int64]$matches[1] * 1KB }
        '^(\d+)\s*MB$' { return [int64]$matches[1] * 1MB }
        '^(\d+)\s*GB$' { return [int64]$matches[1] * 1GB }
        '^(\d+)$'      { return [int64]$matches[1] }
        default {
            Write-Log "Formato di dimensione non riconosciuto: $Size" "ERROR"
            throw "Formato di dimensione non riconosciuto: $Size"
        }
    }
}

function Is-PathExcluded {
    param (
        [string]$FilePath,
        [string[]]$ExcludedPaths,
        [string[]]$ExcludedFiles,
        [string[]]$ExcludedFilePatterns
    )
    
    # Verifica esclusione per percorso
    foreach ($excluded in $ExcludedPaths) {
        if ($FilePath.StartsWith($excluded, [System.StringComparison]::InvariantCultureIgnoreCase)) {
            return $true
        }
    }

    # Verifica esclusione per nome file
    foreach ($excludedFile in $ExcludedFiles) {
        if ([System.IO.Path]::GetFileName($FilePath) -ieq $excludedFile) {
            return $true
        }
    }

    # Verifica esclusione per pattern regex
    foreach ($pattern in $ExcludedFilePatterns) {
        if ($FilePath -match $pattern) {
            return $true
        }
    }

    return $false
}


function Get-FilesToProcess {
    param (
        [string]$Mode,
        [string[]]$FileList,
        [string[]]$Extensions,
        [string[]]$RegexPatterns,
        [string]$SourcePath,
        [switch]$Recurse,
        [string[]]$FullExcludePaths,
        [string[]]$FullExcludeFiles,
        [string[]]$FullExcludeFilePatterns
    )

    $files = @()
    switch ($Mode) {
        'list' {
            foreach ($file in $FileList) {
                $filePath = Join-Path -Path $SourcePath -ChildPath $file
                $resolved = Resolve-Path -Path $filePath -ErrorAction SilentlyContinue
                if ($resolved -and (Test-Path $resolved.Path -PathType Leaf)) {
                    if (-not (Is-PathExcluded $resolved.Path $FullExcludePaths $FullExcludeFiles $FullExcludeFilePatterns)) {
                        # Escludi i file con contenuto auto-generated
                        if ((Get-Content -Path $resolved.Path -ErrorAction SilentlyContinue | Select-String -Pattern "<auto-generated>").Count -eq 0) {
                            $files += $resolved.Path
                        }
                    }
                }
            }
        }
        'extensions' {
            foreach ($ext in $Extensions) {
                $matched = Get-ChildItem -Path $SourcePath -File -Filter "*$ext" -Recurse:$Recurse -ErrorAction SilentlyContinue
                foreach ($file in $matched) {
                    if (-not (Is-PathExcluded $file.FullName $FullExcludePaths $FullExcludeFiles $FullExcludeFilePatterns)) {
                        # Escludi i file con contenuto auto-generated
                        if ((Get-Content -Path $file.FullName -ErrorAction SilentlyContinue | Select-String -Pattern "<auto-generated>").Count -eq 0) {
                            $files += $file.FullName
                        }
                    }
                }
            }
        }
        # Aggiungi altre modalità qui (regex)...
    }

    return $files | Sort-Object -Unique
}

function Normalize-ExcludePaths {
    param (
        [string[]]$ExcludePaths,
        [string]$SourcePath
    )

    $fullExcludePaths = @()
    if ($ExcludePaths) {
        foreach ($path in $ExcludePaths) {
            if (-not [System.IO.Path]::IsPathRooted($path)) {
                $fullPath = Join-Path -Path $SourcePath -ChildPath $path
            } else {
                $fullPath = $path
            }
            $resolvedPaths = Resolve-Path -Path $fullPath -ErrorAction SilentlyContinue
            if ($resolvedPaths) {
                foreach ($resolved in $resolvedPaths) {
                    $fullExcludePaths += $resolved.Path
                    Write-Log "Percorso escluso aggiunto: $($resolved.Path)"
                }
            }
            else {
                Write-Warning "Percorso di esclusione non trovato: $fullPath"
                Write-Log "Percorso di esclusione non trovato: $fullPath" "WARNING"
                Show-Message "Attenzione: Percorso di esclusione non trovato: $fullPath" "Magenta"
            }
        }
        Write-Log "Totale percorsi esclusi: $($fullExcludePaths.Count)"
    }
    return $fullExcludePaths
}

function Validate-Extensions {
    param (
        [string]$Mode,
        [string[]]$Extensions
    )
    if (($Mode -eq 'extensions' -or $Mode -eq 'InteractiveSelection') -and -not $Extensions) {
        Write-Error "La modalità '$Mode' richiede il parametro -Extensions."
        Write-Log "Errore: Modalità '$Mode' senza -Extensions." "ERROR"
        Show-Message "Errore: La modalità '$Mode' richiede il parametro -Extensions." "Red"
        throw "Errore: La modalità '$Mode' richiede il parametro -Extensions."
    }

    if ($Mode -eq 'extensions' -or $Mode -eq 'InteractiveSelection') {
        foreach ($ext in $Extensions) {
            if (-not $ext.StartsWith('.')) {
                Write-Error "L'estensione '$ext' deve iniziare con un punto."
                Write-Log "Errore: Estensione non valida '$ext'." "ERROR"
                Show-Message "Errore: L'estensione '$ext' deve iniziare con un punto." "Red"
                throw "Errore: L'estensione '$ext' deve iniziare con un punto."
            }
        }
    }
}
