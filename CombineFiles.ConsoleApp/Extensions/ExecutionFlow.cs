using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using CombineFiles.ConsoleApp.Helpers;
using CombineFiles.Core;
using CombineFiles.Core.Configuration;
using CombineFiles.Core.Helpers;
using CombineFiles.Core.Infrastructure;
using CombineFiles.Core.Services;
using Spectre.Console;

namespace CombineFiles.ConsoleApp.Extensions;

/// <summary>
/// Contiene la logica di esecuzione principale (Execute) e i metodi di supporto.
/// </summary>
public static class ExecutionFlow
{
    /// <summary>
    /// Entry point del programma, esegue la logica di combinazione dei file.
    /// Viene chiamato dal SetHandler del RootCommand.
    /// </summary>
    public static void Execute(CombineFilesOptions options)
    {
        if (HandleHelpAndPresets(options)) return;
        if (!ApplyPresetSafely(options)) return;

        var logger = InitializeLogger(options);

        if (!ValidateOptions(options, logger)) return;

        string sourcePath = Directory.GetCurrentDirectory();
        var normalizedExcludePaths = PathHelper.NormalizeExcludePaths(options.ExcludePaths, sourcePath, logger);

        ExcludeOutputFileIfNeeded(options, logger);

        var filesToProcess = CollectFiles(options, logger, normalizedExcludePaths, sourcePath);
        filesToProcess = FilterFiles(filesToProcess, options, logger);

        if (filesToProcess.Count == 0)
        {
            logger.WriteLog("Nessun file trovato per l'unione.", LogLevel.WARNING);
            Console.WriteLine("Nessun file trovato per l'unione.");
            return;
        }

        if (!PrepareOutputFile(options, logger)) return;

        MergeFiles(filesToProcess, options, logger);
    }

    #region Metodi Helper di "Execute"

    private static bool HandleHelpAndPresets(CombineFilesOptions options)
    {
        if (options.Help)
        {
            ParameterHelper.PrintHelp();
            return true;
        }
        if (options.ListPresets)
        {
            ParameterHelper.PrintPresetList();
            return true;
        }
        return false;
    }

    private static bool ApplyPresetSafely(CombineFilesOptions options)
    {
        try
        {
            PresetManager.ApplyPreset(options);
            return true;
        }
        catch (Exception ex)
        {
            ConsoleHelper.WriteColored(ex.Message, ConsoleColor.Red);
            return false;
        }
    }

    private static Logger InitializeLogger(CombineFilesOptions options)
    {
        string sourcePath = Directory.GetCurrentDirectory();
        string logFilePath = Path.Combine(sourcePath, "CombineFiles.log");
        var logger = new Logger(
            logFile: logFilePath,
            enabled: options.EnableLog,
            minimumLogLevel: LogLevel.INFO
        );
        logger.WriteLog("Inizio operazione di combinazione file.", LogLevel.INFO);
        return logger;
    }

    private static bool ValidateOptions(CombineFilesOptions options, Logger logger)
    {
        return ParameterHelper.ValidateParameters(options, logger);
    }

    private static void ExcludeOutputFileIfNeeded(CombineFilesOptions options, Logger logger)
    {
        if (!options.OutputToConsole && !string.IsNullOrWhiteSpace(options.OutputFile))
        {
            var outFileName = Path.GetFileName(options.OutputFile);
            if (!string.IsNullOrEmpty(outFileName))
            {
                options.ExcludeFiles.Add(outFileName);
                logger.WriteLog($"Aggiunto {outFileName} alla lista dei file esclusi (per evitare conflitti).", LogLevel.DEBUG);
            }
        }
    }

    private static List<string> CollectFiles(
        CombineFilesOptions options,
        Logger logger,
        List<string> normalizedExcludePaths,
        string sourcePath)
    {
        logger.WriteLog("Inizio raccolta dei file da processare", LogLevel.INFO);
        var fileCollector = new FileCollector(
            logger,
            normalizedExcludePaths,
            options.ExcludeFiles,
            options.ExcludeFilePatterns
        );
        var filesToProcess = FileCollectionHelper.CollectFiles(options, logger, fileCollector, sourcePath);
        logger.WriteLog($"Trovati {filesToProcess.Count} file da processare.", LogLevel.INFO);
        return filesToProcess;
    }

    private static List<string> FilterFiles(
        List<string> files,
        CombineFilesOptions options,
        Logger logger)
    {
        var filtered = FileFilterHelper.FilterByDateAndSize(files, options, logger);

        // Escludiamo i file con tag <auto-generated>
        filtered = filtered.Where(f => !FileFilterHelper.FileContainsAutoGenerated(f, logger)).ToList();
        logger.WriteLog($"Totale file dopo esclusione 'auto-generated': {filtered.Count}", LogLevel.INFO);

        return filtered;
    }

    private static bool PrepareOutputFile(CombineFilesOptions options, Logger logger)
    {
        if (options.OutputToConsole || string.IsNullOrWhiteSpace(options.OutputFile))
            return true;

        try
        {
            Encoding selectedEncoding = Encoding.UTF8;
            OutputFileHelper.PrepareOutputFile(options.OutputFile, options.OutputFormat, selectedEncoding, logger);
            return true;
        }
        catch (Exception ex)
        {
            logger.WriteLog($"Impossibile creare/scrivere il file di output: {ex.Message}", LogLevel.ERROR);
            Console.WriteLine($"Errore: Impossibile creare/scrivere nel file di output: {ex.Message}");
            return false;
        }
    }

    private static void MergeFiles(List<string> filesToProcess, CombineFilesOptions options, Logger logger)
    {
        var fileMerger = new FileMerger(
            logger,
            options.OutputToConsole,
            options.OutputFile,
            options.OutputFormat,
            options.FileNamesOnly
        );

        // Utilizziamo la progress bar di Spectre.Console
        AnsiConsole.Progress()
            .Start(ctx =>
            {
                // Creiamo un task di progressione con un valore massimo pari al numero totale di file
                var progressTask = ctx.AddTask("[green]Merging files...[/]", maxValue: filesToProcess.Count);

                // Elaboriamo ciascun file e aggiorniamo la barra
                foreach (var file in filesToProcess)
                {
                    // Processa il singolo file: implementa la logica in MergeFile
                    fileMerger.MergeFile(file);
                    progressTask.Increment(1);
                }
            });

        if (!options.OutputToConsole)
        {
            logger.WriteLog($"Operazione completata. Controlla il file '{options.OutputFile}'.", LogLevel.INFO);
            Console.WriteLine($"Operazione completata. Controlla il file '{options.OutputFile}'.");
        }
        else
        {
            logger.WriteLog("Operazione completata con output a console.", LogLevel.INFO);
            Console.WriteLine("Operazione completata con output a console.");
        }
    }

    #endregion
}